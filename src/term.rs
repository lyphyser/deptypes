use core::marker::PhantomData;
use crate::type_eq::{TypeEqR, TypeNeR, TypeLeR, TypeLtR, TypeNotLeR, TypeNotLtR};
use crate::transmutable::{Equiv, Transm};

pub trait Term
{
    type Type;
}

/// A term that has no values, used by DPair to erase values
pub struct Erased<T> {_marker: PhantomData<fn() -> T>}

impl<T> Term for Erased<T> {
    type Type = T;
}

pub struct Def<N> {_marker: PhantomData<fn() -> N>}

impl<N> Term for Def<N> {
    type Type = N;
}

#[allow(non_snake_case)]
pub fn Def<N>() -> Value<Def<N>>
    where N: core::default::Default {
    unsafe {Value::new_unchecked(N::default())}
}

impl<N> Def<N> {
    pub fn eq() -> ValueEq<Self, Self> {
        ValueEq::refl()
    }
}

pub struct ValueCmp;
pub type ValueEq<X, Y> = TypeEqR<ValueCmp, X, Y>;
pub type ValueNe<X, Y> = TypeNeR<ValueCmp, X, Y>;
pub type ValueLe<X, Y> = TypeLeR<ValueCmp, X, Y>;
pub type ValueNotLe<X, Y> = TypeNotLeR<ValueCmp, X, Y>;
pub type ValueLt<X, Y> = TypeLtR<ValueCmp, X, Y>;
pub type ValueNotLt<X, Y> = TypeNotLtR<ValueCmp, X, Y>;
pub type ValueGe<X, Y> = TypeLeR<ValueCmp, Y, X>;
pub type ValueNotGe<X, Y> = TypeNotLeR<ValueCmp, Y, X>;
pub type ValueGt<X, Y> = TypeLtR<ValueCmp, Y, X>;
pub type ValueNotGt<X, Y> = TypeNotLtR<ValueCmp, Y, X>;

#[cfg(feature = "gat")]
pub trait Term2Term {
    type Output<T: Term>: Term;
}

/// Value of term A
/// the A::Type value is guaranteed to always be the same for a given type A and instantiation of its lifetimes (this must be respected when unsafely calling new_unchecked or unsafely implementing Eval)
#[repr(transparent)]
pub struct Value<A: Term>(A::Type);

impl_newtype! {
    impl [A] [B] Value(<A as Term>::Type) where [A: Term] [B: Term]
}

impl<A: Term> Value<A> {
    pub fn equiv<B: Term<Type = A::Type>>(_: ValueEq<A, B>) -> Equiv<Value<A>, Value<B>> {
        unsafe {Equiv::axiom()}
    }

    pub fn transm<B: Term>(_: ValueEq<A, B>, _: Transm<A::Type, B::Type>) -> Transm<Value<A>, Value<B>> {
        unsafe {Transm::axiom()}
    }
}

/// Equivalent to match x {y => Ok, _ => Err} in a dependently typed language
pub fn check_value<X: Term, Y: Term>(x: Value<X>, y: Value<Y>) -> Result<
    ValueEq<X, Y>,
    ValueNe<X, Y>
> where X::Type: PartialEq<Y::Type> {
    if x.into_inner() == y.into_inner() {
        Ok(unsafe {ValueEq::axiom()})
    } else {
        Err(unsafe {ValueNe::axiom()})
    }
}

pub fn check_value_le_or_gt<X: Term, Y: Term<Type = X::Type>>(x: Value<X>, y: Value<Y>) -> Result<
    ValueLe<X, Y>,
    ValueGt<X, Y>
> where X::Type: Ord {
    if x.into_inner() <= y.into_inner() {
        Ok(unsafe {ValueLe::axiom()})
    } else {
        Err(unsafe {ValueGt::axiom()})
    }
}

pub fn check_value_le<X: Term, Y: Term>(x: Value<X>, y: Value<Y>) -> Result<
    ValueLe<X, Y>,
    ValueNotLe<X, Y>
> where X::Type: PartialOrd<Y::Type> {
    if x.into_inner() <= y.into_inner() {
        Ok(unsafe {ValueLe::axiom()})
    } else {
        Err(unsafe {ValueNotLe::axiom()})
    }
}

pub fn check_value_lt<X: Term, Y: Term>(x: Value<X>, y: Value<Y>) -> Result<
    ValueLt<X, Y>,
    ValueNotLt<X, Y>
> where X::Type: PartialOrd<Y::Type> {
    if x.into_inner() <= y.into_inner() {
        Ok(unsafe {ValueLt::axiom()})
    } else {
        Err(unsafe {ValueNotLt::axiom()})
    }
}

/// Define a term, consisting of:
/// - A non-instantiable struct type `$name` implementing the Term trait
/// - A constructor function with the same name that creates a Value<`$name`>
/// - A `$name::eq` function that construct a ValueEq from ValueEqs for each term parameter
/// 
/// This macro supports both the terser and recommended fn-like syntax and the slightly more powerful struct-like syntax.
/// 
/// # Example
/// 
/// fn-like syntax:
/// ```rust
/// deptypes::term! {
///     pub fn Add(a, b) -> <a::Type as core::ops::Add<b::Type>>::Output
///         where a::Type: core::ops::Add<b::Type> {
///         core::ops::Add::add(a, b)
///     }
/// }
/// ```
/// 
/// struct-like syntax:
/// ```rust
/// use deptypes::term::Term;
/// 
/// deptypes::term! {
///     pub struct Add<A: Term, B: Term>;
/// 
///     fn(a, b) -> <A::Type as core::ops::Add<B::Type>>::Output
///         where A::Type: core::ops::Add<B::Type> {
///         core::ops::Add::add(a, b)
///     }
/// }
/// ```
/// 
/// Code generated by the macro (for the fn-like version, the struct-like code is equivalent):
/// ```rust
/// use core::marker::PhantomData;
/// use deptypes::term::{Term, Value, ValueEq};
/// 
/// #[allow(non_camel_case_types)]
/// pub struct Add<a: Term, b: Term> {_marker: (PhantomData<fn() -> Value<a>>, PhantomData<fn() -> Value<b>>)}
/// 
/// #[allow(non_camel_case_types)]
/// impl<a: Term, b: Term> Term for Add<a, b>
///     where a::Type: core::ops::Add<b::Type> {
///     type Type = <a::Type as core::ops::Add<b::Type>>::Output;
/// }
/// 
/// #[allow(non_snake_case)]
/// #[allow(non_camel_case_types)]
/// pub fn Add<a: Term, b: Term>(a: Value<a>, b: Value<b>) -> Value<Add<a, b>>
///     where a::Type: core::ops::Add<b::Type> {
///     let (a, b) = (a.into_inner(), b.into_inner());
///     let ret = {core::ops::Add::add(a, b)};
///     unsafe {Value::new_unchecked(ret)}
/// }
/// 
/// #[allow(non_camel_case_types)]
/// impl<a0: Term, b0: Term> Add<a0, b0> {
///     pub fn eq<a1: Term, b1: Term>(_: ValueEq<a0, a1>, _: ValueEq<b0, b1>)
///      -> ValueEq<Self, Add<a1, b1>> {
///         unsafe { ValueEq::axiom() }
///     }
/// }
/// ```
#[macro_export]
macro_rules! term {
    // fn-like Values
    ($(#[$fn_attrs:meta])* $fn_vis:vis fn $fn:ident $($rest:tt)*) => {
        $crate::generics_parse_raw! {
            $crate::term_impl {
                @fn_parse_fn_body
                [$([$fn_attrs])*]
                [$fn_vis]
                $fn
                []
                [$crate::term::Value::new_unchecked]
            }
            $($rest)*
        }
    };

    ($(#[$fn_attrs:meta])* $fn_vis:vis const fn $fn:ident $($rest:tt)*) => {
        $crate::generics_parse_raw! {
            $crate::term_impl {
                @fn_parse_fn_body
                [$([$fn_attrs])*]
                [$fn_vis]
                $fn
                [const]
                [$crate::internal::transmute]
            }
            $($rest)*
        }
    };

    // Struct-like Values
    ($(#[$struct_attrs:meta])* $struct_vis:vis struct $struct:ident $($rest:tt)*) => {
        $crate::generics_parse_raw! {
            $crate::term_impl {
                @struct_parse_fn
                [[$(#[$struct_attrs])*] [$struct_vis] $struct]
                [$struct_vis]
            }
            $($rest)*
        }
    };
}

/// Used by term!
#[doc(hidden)]
#[macro_export]
macro_rules! term_impl {
    // Submacros for fn-like Values
    (@fn_parse_fn_body
        [$([$fn_attrs:meta])*]
        [$fn_vis:vis]
        $fn:ident
        [$($fn_keywords:tt)*]
        [$fn_ret:expr]
        [$fn_gen:tt $fn_arg:tt $fn_where:tt $($fn_extra:tt)*]
        ($($param:tt)*) -> $type:ty {
            $($body:expr);*
        }
    ) => {
        $crate::internal::generics_parse_raw! {
            $crate::term_impl {
                @fn_params
                [
                    [
                        [
                            [[$(#[$fn_attrs])*] [$fn_vis] $fn]
                            [$(#[$fn_attrs])* #[allow(non_snake_case)]] [$fn_vis $($fn_keywords)*] $fn_ret
                        ]
                        $type {$($body);*}
                    ]
                    [$fn_gen $fn_arg $fn_where]
                ]
            }
            <$($param)*>
        }
    };

    (@fn_params
        $ctx:tt
        [
            [$([$($param_gen:tt)*])?]
            [$([$([$($param_arg:tt)*])*])?]
            $param_where:tt
            $($extra:tt)*
        ]
    ) => {
        $crate::term_impl! {
            @fn_parse_params
            [
                $ctx
                [$($($($param_arg)*),*)?]
            ]
            [] []
            [$($($param_gen)*)?]
            [$($([$($param_arg)*])*)?]
            $param_where
        }
    };

    (@fn_parse_params
        $ctx:tt
        [$($add_gen:tt)*]
        [$($add_arg:tt)*]
        [[$name:ident] $($param_gen:tt)*]
        [[$name_arg:ident] $($param_arg:tt)*]
        $param_where:tt
    ) => {
        $crate::term_impl! {
            @fn_parse_params
            $ctx
            [$($add_gen)* [$name : $crate::term::Term]]
            [$($add_arg)* [$name_arg]]
            [$($param_gen)*]
            [$($param_arg)*]
            $param_where
        }
    };

    (@fn_parse_params
        $ctx:tt
        [$($add_gen:tt)*]
        [$($add_arg:tt)*]
        [[$name:ident : $type:ty] $($param_gen:tt)*]
        [[$name_arg:ident] $($param_arg:tt)*]
        $param_where:tt
    ) => {
        $crate::term_impl! {
            @fn_parse_params
            $ctx
            [$($add_gen)* [$name: $crate::term::Term<Type = $type>]]
            [$($add_arg)* [$name_arg]]
            [$($param_gen)*]
            [$($param_arg)*]
            $param_where
        }
    };

    (@fn_parse_params
        [
            [
                $ctx:tt
                [[] [] $fn_where:tt]
            ]
            $fn_args:tt
        ]
        []
        []
        [] [] []
    ) => {
        $crate::term_impl! {
            @fn_output
            $ctx
            []
            [
                []
                []
                $fn_where
            ]
        }
    };

    (@fn_parse_params
        [
            [
                $ctx:tt
                [[$([$($fn_gen:tt)*])?] [$([$($fn_arg:tt)*])?] $fn_where:tt]
            ]
            $fn_args:tt
        ]
        [$($add_gen:tt)*]
        [$($add_arg:tt)*]
        [] [] []
    ) => {
        $crate::term_impl! {
            @fn_output
            $ctx
            $fn_args
            [
                [[$($($fn_gen)*)? $($add_gen)*]]
                [[$($($fn_arg)*)? $($add_arg)*]]
                $fn_where
            ]
        }
    };

    (@fn_output
        $ctx:tt
        $fn_args:tt
        [[$([$([$($struct_gen:tt)*])*])?] [$([$([$($struct_arg:tt)*])*])?] $fn_where:tt]
    ) => {
        $crate::term_impl! {
            @parse_generics
            [
                [
                    [
                        $ctx
                        [#[allow(non_camel_case_types)]]
                        [
                            [$(<$($($struct_gen)*),*>)?]
                            [$(<$($($struct_arg)*),*>)?]
                            []
                        ]
                    ]
                    $fn_args
                ]
                [
                    [$(<$($($struct_gen)*),*>)?]
                    [$(<$($($struct_arg)*),*>)?]
                    $fn_where
                ]
            ]
            [$($([$($struct_gen)*])*)?]
            [] [] [] []
            [] [] [] []
        }
    };

    // Submacros for struct-like Values
    (@struct_parse_fn
        $ctx:tt
        [$struct_vis:vis]
        $struct:tt
        ;
        $(#[$fn_attrs:meta])* const fn $($rest:tt)*
    ) => {
        $crate::term_impl! {
            @struct_parse_fn2
            [$ctx [$(#[$fn_attrs])* #[allow(non_snake_case)]] [$struct_vis const] $crate::internal::transmute]
            $struct
            $($rest)*
        }
    };
    
    (@struct_parse_fn
        $ctx:tt
        [$struct_vis:vis]
        $struct:tt
        ;
        $(#[$fn_attrs:meta])* fn $($rest:tt)*
    ) => {
        $crate::term_impl! {
            @struct_parse_fn2
            [$ctx [$(#[$fn_attrs])* #[allow(non_snake_case)]] [$struct_vis] $crate::term::Value::new_unchecked]
            $struct
            $($rest)*
        }
    };

    (@struct_parse_fn2
        $ctx:tt
        [[$([$([$($struct_raw_gen:tt)*])*])?] [$([$([$($struct_raw_arg:tt)*])*])?] [$($struct_where:tt)*] $($extra:tt)*]
        $($rest:tt)*
        ) => {
        $crate::generics_parse! {
            $crate::term_impl {
                @struct_parse_fn_body 
                $ctx
                [$($([$($struct_raw_gen)*])*)?] [$($([$($struct_raw_arg)*])*)?]
                [[$(<$($($struct_raw_gen)*),*>)?] [$(<$($($struct_raw_arg)*),*>)?] [$($struct_where)*]]
            }
            $($rest)*
        }
    };

    (@struct_parse_fn_body
        $ctx:tt
        $struct_raw_gen:tt $struct_raw_arg:tt
        [$($struct:tt)*]
        [$($fn_gen:tt)*] [$($fn_arg:tt)*] [$($fn_where:tt)*]
        ($($param:ident),*) -> $type:ty {
            $($body:expr);*
        }
    ) => {
        $crate::generics_concat! {
            $crate::term_impl {
                @struct_concat
                [[[$ctx $type {$($body);*}] [] [$($struct)*]] [$($param),*]]
                $struct_raw_gen $struct_raw_arg
            }
            $($struct)*, [$($fn_gen)*] [$($fn_arg)*] [$($fn_where)*]
        }
    };

    (@struct_concat
        $ctx:tt
        $struct_raw_gen:tt $struct_raw_arg:tt
        [$($concat_gen:tt)*] [$($concat_arg:tt)*] [$($concat_where:tt)*]
    ) => {
        $crate::term_impl! {
            @parse_generics
            [
                $ctx
                [[$($concat_gen)*] [$($concat_arg)*] [$($concat_where)*]]
            ]
            $struct_raw_gen
            [] [] [] []
            [] [] [] []
        }
    };

    // Submacros common for struct-like and fn-like Values
    (@parse_generics
        $ctx:tt
        [[const $name:ident $($tokens:tt)*] $($gen_rest:tt)*]
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@parse_generics $ctx
            [$($gen_rest)*]
            [$($lifetimes_c)*]
            [$($types_c)*]
            [$($Values_c)*]
            [$($consts_c)*  [$($tokens)*]]
            [$($lifetimes)*]
            [$($types)*]
            [$($Values)*]
            [$($consts)* $name]
        }
    };
    
    (@parse_generics
        $ctx:tt
        [[$lifetime:lifetime $($tokens:tt)*] $($gen_rest:tt)*]
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@parse_generics $ctx
            [$($gen_rest)*]
            [$($lifetimes_c)* [$($tokens)*]]
            [$($types_c)*]
            [$($Values_c)*]
            [$($consts_c)*]
            [$($lifetimes)* $lifetime]
            [$($types)*]
            [$($Values)*]
            [$($consts)*]
        }
    };

    // TODO: this unfortunately matches <any crate>::term::Term, but I don't think there's a better
    (@parse_generics
        $ctx:tt
        [[$name:ident : $krate:tt :: term :: Term $($tokens:tt)*] $($gen_rest:tt)*]
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@parse_generics $ctx
            [$($gen_rest)*]
            [$($lifetimes_c)*]
            [$($types_c)*]
            [$($Values_c)* [: $krate ::term::Term $($tokens)*]]
            [$($consts_c)*]
            [$($lifetimes)*]
            [$($types)*]
            [$($Values)* $name]
            [$($consts)*]
        }
    };

    (@parse_generics
        $ctx:tt
        [[$name:ident : Term $($tokens:tt)*] $($gen_rest:tt)*]
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@parse_generics $ctx
            [$($gen_rest)*]
            [$($lifetimes_c)*]
            [$($types_c)*]
            [$($Values_c)* [: Term $($tokens)*]]
            [$($consts_c)*]
            [$($lifetimes)*]
            [$($types)*]
            [$($Values)* $name]
            [$($consts)*]
        }
    };

    (@parse_generics
        $ctx:tt
        [[$type:tt $($tokens:tt)*] $($gen_rest:tt)*]
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@parse_generics $ctx
            [$($gen_rest)*]
            [$($lifetimes_c)*]
            [$($types_c)* [$($tokens)*]]
            [$($Values_c)*]
            [$($consts_c)*]
            [$($lifetimes)*]
            [$($types)* $type]
            [$($Values)*]
            [$($consts)*]
        }
    };

    (@parse_generics
        [[$ctx:tt [$($fn_arg:tt),*]] $concat:tt]
        []
        [$($lifetimes_c:tt)*] [$($types_c:tt)*] [$($Values_c:tt)*] [$($consts_c:tt)*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
    ) => {
        $crate::term_impl! {@output [[$ctx [$($fn_arg),*]] $concat]
            [$($lifetimes_c)*]
            [$($types_c)*]
            [$($Values_c)*]
            [$($consts_c)*]
            [$($lifetimes)*]
            [$($types)*]
            [$($Values)*]
            [$($consts)*]
            [$([$fn_arg: $crate::term::Value<$Values>])*]
        }
    };

    (@output
        [
            [
                [
                    [
                        [
                            [
                                [$($struct_attrs:tt)*] [$($struct_keywords:tt)*] $struct:ident
                            ]
                            [$($fn_attrs:tt)*] [$($fn_keywords:tt)*] $fn_ret:expr
                        ]
                        $type:ty {$($body:expr);*}
                    ]
                    [$($struct_gen_attrs:tt)*]
                    [[$($struct_gen:tt)*] [$($struct_arg:tt)*] [$($struct_where:tt)*]]
                ]
                [$($fn_arg:ident),*]
            ]
            [[$($concat_gen:tt)*] [$($concat_arg:tt)*] [$($concat_where:tt)*]]
        ]
        [$([$($lifetimes_c:tt)*])*] [$([$($types_c:tt)*])*] [$([$($Values_c:tt)*])*] [$([$($consts_c:tt)*])*]
        [$($lifetimes:lifetime)*] [$($types:ident)*] [$($Values:ident)*] [$($consts:ident)*]
        [$([$($fn_param:tt)*])*]
    ) => {
        $($struct_attrs)* $($struct_gen_attrs)* $($struct_keywords)* struct $struct $($struct_gen)* $($struct_where)* {_marker: ($($crate::internal::PhantomData<fn() -> $crate::term::Value<$Values>>,)* $($crate::internal::PhantomData<fn() -> $types>,)*)}

        $($struct_gen_attrs)* impl $($struct_gen)* $crate::term::Term for $struct $($struct_arg)*
            $($concat_where)* {
            type Type = $type;
        }

        $($fn_attrs)* $($struct_gen_attrs)* $($fn_keywords)* fn $struct $($struct_gen)* ($($($fn_param)*),*) -> $crate::term::Value<$struct $($struct_arg)*>
            $($concat_where)* {
            let ($($fn_arg,)*) = ($($fn_arg.into_inner(),)*);
            let ret = {$($body);*};
            unsafe {$fn_ret(ret)}
        }

        $crate::paste! {
            $($struct_gen_attrs)* impl<$($lifetimes $($lifetimes_c)*,)* $($types $($types_c)*,)* $([<$Values 0>] $($Values_c)*,)* $(const $consts $($consts_c)*,)*> $struct<$($lifetimes,)* $($types,)* $([<$Values 0>],)* $($consts,)*> {
                pub fn eq<$([<$Values 1>] $($Values_c)*,)*> ($(_: $crate::term::ValueEq<[<$Values 0>], [<$Values 1>]>),*) -> $crate::term::ValueEq<Self, $struct<$($lifetimes,)* $($types,)* $([<$Values 1>],)* $($consts,)*>> {
                    unsafe {$crate::term::ValueEq::axiom()}
                }
            }
        }
    };
}
